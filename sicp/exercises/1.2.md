# Exercises for Chapter 1, Section 2

**Exercise 1.9.**

Each of the following two procedures defines a method for adding two positive
integers in terms of the procedures inc, which increments its argument by 1,
and dec, which decrements its argument by 1.

```scheme
(define (+ a b)
  (if (= a 0)
      b
      (inc (+ (dec a) b))))

(define (+ a b)
  (if (= a 0)
      b
      (+ (dec a) (inc b))))
```

Using the substitution model, illustrate the process generated by each
procedure in evaluating (+ 4 5). Are these processes iterative or recursive?

**Answer 1.9.**

First definition of `+`:

```scheme
(+ 4 5)
(inc (+ (dec 4 ) 5))
(inc (+ 3 5))
(inc (inc (+ (dec 3) 5)))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ (dec 2) 5))))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ (dec 1) 5)))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9
```

Second definition of `+`:

```scheme
(+ 4 5)
(+ (dec 4) (inc 5))
(+ 3 6)
(+ (dec 3) (inc 6))
(+ 2 7)
(+ (dec 2) (inc 7))
(+ 1 8)
(+ (dec 1) (inc 8))
(+ 0 9)
9
```

As we can see from the processes above, definition 1 is recursive, while
definition 2 is iterative.

**Exercise 1.10a.**

The following procedure computes a mathematical function called Ackermann's
function.

```scheme
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))
```

 What are the values of the following expressions?

 ```scheme
(A 1 10)

(A 2 4)

(A 3 3)
```

**Answer 1.10a.**

Let's get a sense of how `A` works by stepping through the process defined by
the first expression:

```scheme
(A 1 10)
(A (- 1 1) (A 1 (- 10 1)))
(A 0 (A 1 9)))
(A 0 (A (- 1 1) (A 1 (- 9 1))))
(A 0 (A 0 (A 1 8))))
(A 0 (A 0 (A (- 1 1) (A 1 (- 8 1)))))
...
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))) 
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4)))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16)))))
(A 0 (A 0 (A 0 (A 0 (A 0 32))))
(A 0 (A 0 (A 0 (A 0 64)))
(A 0 (A 0 (A 0 128)))
(A 0 (A 0 256)
(A 0 512)
1024
```

So the first expression, `(A 1 10)`, evaluates to `512`.

Let's try the second expression:

```scheme
(A 2 4)
(A 1 (A 2 3))
(A 1 (A 1 (A 2 2)))
(A 1 (A 1 (A 1 (A 2 1))))
(A 1 (A 1 (A 1 2)))
(A 1 (A 1 (A 0 (A 1 1))))
(A 1 (A 1 (A 0 2))
(A 1 (A 1 4)))
(A 1 (A 0 (A 1 3)))
(A 1 (A 0 (A 0 (A 1 2))))
(A 1 (A 0 (A 0 (A 0 (A 1 1)))))
(A 1 (A 0 (A 0 (A 0 2))))
(A 1 (A 0 (A 0 4)))
(A 1 (A 0 8))
(A 1 16)
...
65536
```

(Note that I skipped a whole chain of recursion in the final `...`, since the
expression became similar enough to the first expression that we could infer
where it would go.)

Finally, let's take a look at the third expression:

```scheme
(A 3 3)
(A 2 (A 3 2))
(A 2 (A 2 (A 3 1)))
(A 2 (A 2 2))
(A 2 (A 1 (A 2 1)))
(A 2 (A 1 2))
(A 2 (A 0 (A 1 1)))
(A 2 (A 0 2))
(A 2 4)
...
65536
```

Interesting... it evaluates to the same value as the second expression!

**Exercise 1.10b**

Consider the following procedures, where `A` is the procedure defined above
(Ackerman's function):

```scheme
(define (f n) (A 0 n))

(define (g n) (A 1 n))

(define (h n) (A 2 n))

(define (k n) (* 5 n n))
```

Give concise mathematical definitions for the functions computed by the
procedures `f`, `g`, and `h` for positive integer values of `n`. For example,
`(k n)` computes $5n^2$.

**Answer 1.10b**

For clarity's sake, let's notate Ackerman's function like so moving forward:

$$A(X, Y)$$

I spent a long time looking for a generalizable function here, but it's not so
easy with standard mathematical notation. Instead, let's take a look at the
logic.

When $X = 0$, the function immediately satisfies the second condition of the
procedure definition, so we can easily say:

$$A(0, n) = 2 \dot n$$

When $X = 1$, conditions are similar to the first procedure above. This one's
fairly simple too:

$$A(1, n) = 2^{n}$$

When $X = 2$, things get a little bit stranger. My initial guess was the one
that appeared the most obvious to me:

$$A(2, n) = 2^{n^{2}}$$

But this was misleading! For example, a quick sketch will find that:

$$A(2, 3) = 16$$

Which is not at all what we would predict from the above formula.

I had to do some digging around online to figure this one out, but it turns out
that Ackerman's function (or at least this definition of it, anyway) helps
define _hyperoperations_: operators that extend beyond exponentiation. (For
a sense of what "beyond" means, consider that multiplication is iterated
addition, and exponentiation is iterated multiplication; think about what it
might mean to iterate exponentation, or to iterate _that_ operation -- whatever
it's called!)

In this case, $A(2, n)$ is describing the hyperoperation that iterates
exponentiation: _tetration_. We can notate it using Knuth's up-arrow notation:

$$A(2, n) = 2 \uparrow \uparrow n$$

Which is equivalent to $2^{n}^{n}...$ $n-1$ times. Phew!

-----

**Exercise 1.11.**

A function `f` is defined by the rule that `f(n) = n` if `n < 3` and
`f(n) = f(n - 1) + 2f(n - 2) + 3f(n - 3)` if `n > 3`. Write a procedure that
computes `f` by means of a recursive process. Write a procedure that computes
`f` by means of an iterative process. 

**Answer 1.11.**

The recursive definition of the function is easy, since it doesn't take much
to translate the prose into Scheme:

```scheme
(define (f-rec n)
    (if (< n 3)
        n
        (+ (f-rec (- n 1))
           (* 2 (f-rec (- n 2)))
           (* 3 (f-rec (- n 3))))))
```

The iterative definition is trickier! The key for me was to notice that this
is basically a modified Fibonacci sequence. We can take a similar approach,
using a counter and state variables (in this case three state variables, since
we're summing three previous terms whereas Fibonacci sums two) to count up when
`n > 3`.

When `n < 3`, however, I fall back to using the recursive version of the
function. By some definitions, this means that the process may not be truly
iterative: it relies on recursive subprocesses for `3 <= n <= 6>`. But I think
it counts, because the worst case behavior is bounded and set where `n = 5`,
and we know the maximum amount of space the program will take up (very small).
We could make it a purely iterative process by hard-coding the values of the
function where `3 <= n <= 6>`, but I think that's ugly, so I'm not going to do
it.
    
```scheme
(define (f-iter n)
    (define (iter a b c count)
        (if (= count 0)
            b
            (iter (+ a (* 2 b) (* 3 c)) a b (- count 1))))
    (if (> n 6)
        (iter (f-rec 5) (f-rec 4) (f-rec 3) n)
        (f-rec n)))
```
