# Exercises for Chapter 1, Section 2

**Exercise 1.9.**

Each of the following two procedures defines a method for adding two positive
integers in terms of the procedures inc, which increments its argument by 1,
and dec, which decrements its argument by 1.

```scheme
(define (+ a b)
  (if (= a 0)
      b
      (inc (+ (dec a) b))))

(define (+ a b)
  (if (= a 0)
      b
      (+ (dec a) (inc b))))
```

Using the substitution model, illustrate the process generated by each
procedure in evaluating (+ 4 5). Are these processes iterative or recursive?

**Answer 1.9.**

First definition of `+`:

```scheme
(+ 4 5)
(inc (+ (dec 4 ) 5))
(inc (+ 3 5))
(inc (inc (+ (dec 3) 5)))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ (dec 2) 5))))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ (dec 1) 5)))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9
```

Second definition of `+`:

```scheme
(+ 4 5)
(+ (dec 4) (inc 5))
(+ 3 6)
(+ (dec 3) (inc 6))
(+ 2 7)
(+ (dec 2) (inc 7))
(+ 1 8)
(+ (dec 1) (inc 8))
(+ 0 9)
9
```

As we can see from the processes above, definition 1 is recursive, while
definition 2 is iterative.

**Exercise 1.10a.**

The following procedure computes a mathematical function called Ackermann's
function.

```scheme
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))
```

 What are the values of the following expressions?

 ```scheme
(A 1 10)

(A 2 4)

(A 3 3)
```

**Answer 1.10a.**

Let's get a sense of how `A` works by stepping through the process defined by
the first expression:

```scheme
(A 1 10)
(A (- 1 1) (A 1 (- 10 1)))
(A 0 (A 1 9)))
(A 0 (A (- 1 1) (A 1 (- 9 1))))
(A 0 (A 0 (A 1 8))))
(A 0 (A 0 (A (- 1 1) (A 1 (- 8 1)))))
...
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))) 
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4)))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16)))))
(A 0 (A 0 (A 0 (A 0 (A 0 32))))
(A 0 (A 0 (A 0 (A 0 64)))
(A 0 (A 0 (A 0 128)))
(A 0 (A 0 256)
(A 0 512)
1024
```

So the first expression, `(A 1 10)`, evaluates to `512`.

Let's try the second expression:

```scheme
(A 2 4)
(A 1 (A 2 3))
(A 1 (A 1 (A 2 2)))
(A 1 (A 1 (A 1 (A 2 1))))
(A 1 (A 1 (A 1 2)))
(A 1 (A 1 (A 0 (A 1 1))))
(A 1 (A 1 (A 0 2))
(A 1 (A 1 4)))
(A 1 (A 0 (A 1 3)))
(A 1 (A 0 (A 0 (A 1 2))))
(A 1 (A 0 (A 0 (A 0 (A 1 1)))))
(A 1 (A 0 (A 0 (A 0 2))))
(A 1 (A 0 (A 0 4)))
(A 1 (A 0 8))
(A 1 16)
...
65536
```

(Note that I skipped a whole chain of recursion in the final `...`, since the
expression became similar enough to the first expression that we could infer
where it would go.)

Finally, let's take a look at the third expression:

```scheme
(A 3 3)
(A 2 (A 3 2))
(A 2 (A 2 (A 3 1)))
(A 2 (A 2 2))
(A 2 (A 1 (A 2 1)))
(A 2 (A 1 2))
(A 2 (A 0 (A 1 1)))
(A 2 (A 0 2))
(A 2 4)
...
65536
```

Interesting... it evaluates to the same value as the second expression!

**Exercise 1.10b**

Consider the following procedures, where `A` is the procedure defined above
(Ackerman's function):

```scheme
(define (f n) (A 0 n))

(define (g n) (A 1 n))

(define (h n) (A 2 n))

(define (k n) (* 5 n n))
```

Give concise mathematical definitions for the functions computed by the
procedures `f`, `g`, and `h` for positive integer values of `n`. For example,
`(k n)` computes $5n^2$.

**Answer 1.10b**

For clarity's sake, let's notate Ackerman's function like so moving forward:

$$A(X, Y)$$

I spent a long time looking for a generalizable function here, but it's not so
easy with standard mathematical notation. Instead, let's take a look at the
logic.

When $X = 0$, the function immediately satisfies the second condition of the
procedure definition, so we can easily say:

$$A(0, n) = 2 \dot n$$

When $X = 1$, conditions are similar to the first procedure above. This one's
fairly simple too:

$$A(1, n) = 2^{n}$$

When $X = 2$, things get a little bit stranger. My initial guess was the one
that appeared the most obvious to me:

$$A(2, n) = 2^{n^{2}}$$

But this was misleading! For example, a quick sketch will find that:

$$A(2, 3) = 16$$

Which is not at all what we would predict from the above formula.

I had to do some digging around online to figure this one out, but it turns out
that Ackerman's function (or at least this definition of it, anyway) helps
define _hyperoperations_: operators that extend beyond exponentiation. (For
a sense of what "beyond" means, consider that multiplication is iterated
addition, and exponentiation is iterated multiplication; think about what it
might mean to iterate exponentation, or to iterate _that_ operation -- whatever
it's called!)

In this case, $A(2, n)$ is describing the hyperoperation that iterates
exponentiation: _tetration_. We can notate it using Knuth's up-arrow notation:

$$A(2, n) = 2 \uparrow \uparrow n$$

Which is equivalent to $2^{n}^{n}...$ $n-1$ times. Phew!

-----

**Exercise 1.11.**

A function `f` is defined by the rule that `f(n) = n` if `n < 3` and
`f(n) = f(n - 1) + 2f(n - 2) + 3f(n - 3)` if `n > 3`. Write a procedure that
computes `f` by means of a recursive process. Write a procedure that computes
`f` by means of an iterative process. 

**Answer 1.11.**

The recursive definition of the function is easy, since it doesn't take much
to translate the prose into Scheme:

```scheme
(define (f-rec n)
    (if (< n 3)
        n
        (+ (f-rec (- n 1))
           (* 2 (f-rec (- n 2)))
           (* 3 (f-rec (- n 3))))))
```

The iterative definition is trickier! The key for me was to notice that this
is basically a modified Fibonacci sequence. We can take a similar approach,
using a counter and state variables (in this case three state variables, since
we're summing three previous terms whereas Fibonacci sums two) to count up when
`n > 3`.

When `n < 3`, however, I fall back to using the recursive version of the
function. By some definitions, this means that the process may not be truly
iterative: it relies on recursive subprocesses for `3 <= n <= 6>`. But I think
it counts, because the worst case behavior is bounded and set where `n = 5`,
and we know the maximum amount of space the program will take up (very small).
We could make it a purely iterative process by hard-coding the values of the
function where `3 <= n <= 6>`, but I think that's ugly, so I'm not going to do
it.
    
```scheme
(define (f-iter n)
    (define (iter a b c count)
        (if (= count 0)
            b
            (iter (+ a (* 2 b) (* 3 c)) a b (- count 1))))
    (if (> n 6)
        (iter (f-rec 5) (f-rec 4) (f-rec 3) n)
        (f-rec n)))
```

-----

**Exercise 1.12.**

The following pattern of numbers is called _Pascal's triangle._

```
1
1 1
1 2 1
1 3 3 1
1 4 6 4 1
...
```

The numbers at the edge of the triangle are all 1, and each number
inside the triangle is the sum of the two numbers above it. Write a
procedure that computes elements of Pascal's triangle by means of a
recursive process. 

**Answer 1.12.**

If we consider each element of Pascal's triangle to have both a row and
a column value, we can treat it like a tree and write a procedure to recurse
the tree and compute the value for a given row/col position:

```scheme
(define (pascal row col)
  ;;; Calculate a value in Pascal's triangle for a given row/col position
  (cond ((or (= col 1) (= row col)) 1)
        ((or (< col 1) (> col row)) 0)
        (else (+ (pascal (- row 1) (- col 1))
                 (pascal (- row 1) col)))))
```

If we cheat a little bit and make use of two string manipulation procedures
that we haven't encountered yet in the text (`write-to-string`, which
casts a value to a string, and `string-append`, which concatenates two strings)
then we can write a procedure that uses the `pascal` procedure to print the
binomial coefficients of `n`:

```scheme
(define (coef n)
  ;;; Display the binomial coefficients for `n`
  (define (pascal-row row col)
    (if (= row col)
        (write-to-string (pascal row col))
        (string-append (write-to-string (pascal row col))
                        " "
                        (pascal-row row (+ col 1)))))
  (pascal-row n 1))
```

Let's go a step further! Using a similar recursive logic, we can in turn build
on the `coef` procedure to print an inverted representation of Pascal's triangle
starting at `n`:

```scheme
(define (pascals-triangle n)
  ;;; Display an inverted version of Pascal's triangle starting
  ;;; at row `n`
  (define (build-triangle n)
    (if (= n 1)
        (coef n)
        (string-append (coef n) "\n" (build-triangle (- n 1)))))
  (display (build-triangle n)))
```

(If we wanted to keep the party going, we could extend this procedure even
further by writing a version that inverts the triangle to start at `n = 1`. It
would also be fun to write a `pretty-pascal` function that adds spaces in the
right spot to print the triangle in a symmetric fashion!)

-----

**Exercise 1.15.**

The sine of an angle (specified in radians) can be computed by making use of
the approximation `sin(x) = x` if `x` is sufficiently small, and the trigonometric
identity

```
sin(x) = (3 * sin(x/3)) - (4 * sin(x/3)^3)
```

to reduce the size of the argument of sin. (For purposes of this exercise an
angle is considered "sufficiently small" if its magnitude is not greater than
0.1 radians.) These ideas are incorporated in the following procedures:

```scheme
(define (cube x) (* x x x))
(define (p x) (- (* 3 x) (* 4 (cube x))))
(define (sine angle)
   (if (not (> (abs angle) 0.1))
       angle
       (p (sine (/ angle 3.0)))))
```

**Exercise 1.15.a**

How many times is the procedure `p` applied when `(sine 12.15)` is evaluated?

**Answer 1.15.a.**

A simple way to figure this out is just to step through the process:

```scheme
(sine 12.15)
(p (sine 4.05))
(p (p (sine 1.35)))
(p (p (p (sine 0.45))))
(p (p (p (p (sine 0.15))))
(p (p (p (p (p (sine 0.05)))))
(p (p (p (p (p 0.05)))))
```

At this point, the process will begin to contract as it evaluates the deferred
operations. Hence, the procedure `p` is evaluated **5 times**.

**Exercise 1.15.b**

What is the order of growth in space and number of steps (as a function of `a`)
used by the process generated by the `sine` procedure when `(sine a)` is
evaluated? 

**Answer 1.15.b**

Looking at our answer to 1.15.a, we can argue intuitively that the number of
steps and the amount of space required to evaluate the `sine` procedure will
grow at the same rate. So if we can determine the order of growth for one of
these attributes, we'll know the order of growth for both.

Additionally, the input seems to be shrinking at a slowing rate: first it's
about 12, then about 4, then about 1.5, and so on. It "feels" logarithmic.
To verify this formally, we can say that the number of steps that it will take
before the process begins to contract can be represented by solving the
following relationship for `n:`

```
x / (3^n) = 0.1
```

Where `x` is the size of the input. (In English, this relationship is saying
"We will have to divide `x` by 3 and repeat that division `n` times before we
reach the required threshold of `n < 0.1`.") Solving for `n`:

```
x = 0.1 * (3^n)
10 * x = 3^n
n = log3(10 * x)
```

So the `sine` procedure indeed grows with O(log n).

-----

**Exercise 1.16.**

Design a procedure that evolves an iterative exponentiation process that uses
successive squaring and uses a logarithmic number of steps, as does `fast-expt`.
(Hint: Using the observation that `(b^(n/2))^2 = (b^2)^(n/2)`, keep, along with the
exponent `n` and the base `b`, an additional state variable `a`, and define the state
transformation in such a way that the product `a * b^n` is unchanged from state to
state. At the beginning of the process `a` is taken to be 1, and the answer is
given by the value of `a` at the end of the process. In general, the technique of
defining an invariant quantity that remains unchanged from state to state is
a powerful way to think about the design of iterative algorithms.)

**Answer 1.16.**

```scheme
(define (expt-iter b n)
  (define (iter a b n)
    (cond ((= 0 n) a)
          ((= 1 n) b)
          ((even? n) (iter b (* b b) (/ n 2)))
          (else (* b (iter a b (- n 1))))))
  (define (even? n)
    (= (remainder n 2) 0))
  (iter 1 b n))
```

-----

**Exercise 1.17.**

The exponentiation algorithms in this section are based on performing
exponentiation by means of repeated multiplication. In a similar way, one can
perform integer multiplication by means of repeated addition. The following
multiplication procedure (in which it is assumed that our language can only
add, not multiply) is analogous to the `expt` procedure:

```scheme
(define (* a b)
  (if (= b 0)
      0
      (+ a (* a (- b 1)))))
```

This algorithm takes a number of steps that is linear in `b`. Now suppose we
include, together with addition, operations `double`, which doubles an integer,
and `halve`, which divides an (even) integer by 2. Using these, design
a multiplication procedure analogous to `fast-expt` that uses a logarithmic
number of steps.

**Answer 1.17.**

```scheme
(define (double n)
  (+ n n))

(define (halve n)
  (/ n 2))

(define (even? n)
  (= (remainder n 2) 0))

(define (fast-mult a b)
  ;; Multiply two numbers in O(log n) time
  (cond ((= b 0) 0)
        ((even? b) (double (fast-mult a (halve b))))
        (else (+ a (fast-mult a (- b 1))))))
```
