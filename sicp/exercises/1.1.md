# Exercises for Chapter 1, Section 1

**Exercise 1.1.**  Below is a sequence of expressions. What is the result printed by the interpreter in response to each expression? Assume that the sequence is to be evaluated in the order in which it is presented.

```scheme
10
(+ 5 3 4)
(- 9 1)
(/ 6 2)
(+ (* 2 4) (- 4 6))
(define a 3)
(define b (+ a 1))
(+ a b (* a b))
(= a b)
(if (and (> b a) (< b (* a b)))
    b
    a)
(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25))
(+ 2 (if (> b a) b a))
(* (cond ((> a b) a)
         ((< a b) b)
         (else -1))
   (+ a 1))
```

**Answer 1.1.**

```
> 10
10

> (+ 5 3 4)
12

> (- 9 1)
8

> (/ 6 2)
3

> (+ (* 2 4) (- 4 6))
6

> (define a 3)
Value: a

> (define b (+ a 1))
Value: b

> (+ a b (* a b))
19

> (= a b)
#f

> (if (and (> b a) (< b (* a b)))
>     b
>     a)
4

> (cond ((= a 4) 6)
>       ((= b 4) (+ 6 7 a))
>       (else 25))
16

> (+ 2 (if (> b a) b a))
6

> (* (cond ((> a b) a)
>          ((< a b) b)
>          (else -1))
>    (+ a 1))
16
```

-----

**Exercise 1.3.**

Define a procedure that takes three numbers as arguments and returns
the sum of the squares of the two larger numbers. 

**Answer 1.3**

```scheme
(define (sum-square-the-larger-two a b c)
	(cond ((and (<= a b) (<= a c)) (+ (* b b) (* c c)))
	      ((and (<= b a) (<= b c)) (+ (* a a) (* c c)))
	      ((and (<= c a) (<= c b)) (+ (* a a) (* b b)))))
```

-----

**Exercise 1.4.**

Observe that our model of evaluation allows for combinations whose
operators are compound expressions. Use this observation to describe
the behavior of the following procedure:

```scheme
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
```

**Answer 1.4.**

The procedure `a-plus-abs-b` does precisely what its procedure name  indicates:
sums the first argument with the absolute value of the second argument. It
accomplishes this task in a clever way, using a compound conditional expression
as an operator. Rather than define an `abs` procedure to take the absolute
value of the second argument, `a-plus-abs-b` varies its operator depending on
the value of `b`: if `b > 0`, the operator evaluates to `+`; otherwise, the
operator evaluates to `-`. Functionally, this move accomplishes an "anonymous"
absolute value procedure... nifty!

-----

**Exercise 1.5.**

Ben Bitdiddle has invented a test to determine whether the interpreter he is
faced with is using applicative-order evaluation or normal-order evaluation.
He defines the following two procedures: 

```scheme
(define (p) (p))

(define (test x y)
  (if (= x 0)
      0
      y))
```

Then he evaluates the expression

```scheme
(test 0 (p))
```

What behavior will Ben observe with an interpreter that uses applicative-order
evaluation? What behavior will he observe with an interpreter that uses
normal-order evaluation? Explain your answer. (Assume that the evaluation rule
for the special form `if` is the same whether the interpreter is using normal or
applicative order: The predicate expression is evaluated first, and the result
determines whether to evaluate the consequent or the alternative expression.) 

**Answer 1.5.**

If the interpreter uses applicative-order evaluation ("evaluate arguments,
then apply"), it will get caught in an empty loop when it tries to run the
expression to be evaluated (`(test 0 (p))`): since the interpreter wants to
evaluate all arguments ahead of time, it will recurse endlessly trying to
define `p`.

If the interpreter uses normal-order evaluation (or "lazy evaluation"), on the
other hand, the procedure will execute normally and return a value of 0. Since
in this case the interpreter is waiting to evaluate expressions until they are
required by a primitive operation, it will never actually be forced to evaluate
the endlessly recursive expression `(p)`.
