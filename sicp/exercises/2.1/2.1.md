# Exercises for Chapter 2.1

**Exercise 2.1.**

Define a better version of `make-rat` that handles both positive and negative
arguments. `make-rat` should normalize the sign so that if the rational number is
positive, both the numerator and denominator are positive, and if the rational
number is negative, only the numerator is negative. 

**Answer 2.1**

```scheme
(define (make-rat n d)
  ;; Constructor for rational numbers.
  ;; Handles negative numbers, and reduces fractions.
  (let ((g (gcd n d))
        (neg (lambda (x) (- 0 (abs x)))))
    (cond ((or (and (negative? n) (negative? d))
               (and (not (negative? n)) (not (negative? d))))
            (cons (/ (abs n) g) (/ (abs d) g)))
          (else
            (cons (/ (neg n) g) (/ (abs d) g))))))
```

**Exercise 2.2.**

Consider the problem of representing line segments in a plane. Each segment is
represented as a pair of points: a starting point and an ending point.

**Exercise 2.2.a**

Define a constructor `make-segment` and selectors `start-segment` and `end-segment`
that define the representation of segments in terms of points.

**Answer 2.2.a**

Since a line segment is just an ordered pair of points, the naive way to
implement segment operations is to assign the names of the operations to the
existing pair analogues (c.f. [footnote 3, ch.
2.1](https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-14.html#footnote_Temp_135)):

```scheme
(define make-segment
  ;;; Constructor procedure that takes two points and returns a line segment
  cons)

(define start-segment
  ;;; Selector procedure that takes a line segment and returns its initial point
  car)

(define end-segment
  ;;; Selector procedure that takes a line segment and returns its endpoint
  cdr)
```

**Exercise 2.2.b**

Furthermore, a point
can be represented as a pair of numbers: the x coordinate and the y coordinate.
Accordingly, specify a constructor `make-point` and selectors `x-point` and `y-point`
that define this representation.

**Answer 2.2.b**

Once again, a point is simply an ordered pair of numbers! As long as we don't
really care about tracing these functions (and if we don't want to do any
intricate input analysis, to sniff out bad inputs) we can once again assign the 
procedure names to the names of existing pair operations:

```scheme
(define make-point cons)

(define x-point car)

(define y-point cdr)
```

**Exericse 2.2.c.**

Finally, using your selectors and
constructors, define a procedure `midpoint-segment` that takes a line segment as
argument and returns its midpoint (the point whose coordinates are the average
of the coordinates of the endpoints). To try your procedures, you'll need a way
to print points:

```scheme
(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))
```

**Answer 2.2.c**

The midpoint of a line segment is simply the coordinate corresponding to the
average of the x-coordinates of the endpoints, and the average of the
y-coordinates of the endpoints. In Scheme, this is easy:

```scheme
(define (midpoint-segment s)
  ;;; Find the midpoint of a line segment `s`.
  (make-point (average (x-point (start-segment s))
                       (x-point (end-segment s)))
              (average (y-point (start-segment s))
                       (y-point (end-segment s)))))
```

-----

**Exercise 2.3.**

Implement a representation for rectangles in a plane. (Hint: You may want to
make use of exercise 2.2.) In terms of your constructors and selectors, create
procedures that compute the perimeter and the area of a given rectangle. Now
implement a different representation for rectangles. Can you design your system
with suitable abstraction barriers, so that the same perimeter and area
procedures will work using either representation? 
